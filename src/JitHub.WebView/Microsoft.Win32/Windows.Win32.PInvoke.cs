// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using winmdroot = global::Windows.Win32;
namespace Windows.Win32
{
    internal static partial class PInvoke
    {
        internal const uint WM_LBUTTONDOWN = 513U;
        internal const uint WM_LBUTTONUP = 514U;
        internal const uint WM_MBUTTONDOWN = 519U;
        internal const uint WM_MBUTTONUP = 520U;
        internal const uint WM_RBUTTONDOWN = 516U;
        internal const uint WM_RBUTTONUP = 517U;
        internal const uint WM_XBUTTONDOWN = 523U;
        internal const uint WM_XBUTTONUP = 524U;
        internal const uint WM_POINTERDOWN = 582U;
        internal const uint WM_POINTERUP = 583U;
        internal const uint WM_MOUSEMOVE = 512U;
        internal const uint WM_MOUSELEAVE = 675U;
        internal const uint WM_POINTERUPDATE = 581U;
        internal const uint WM_POINTERLEAVE = 586U;
        internal const uint WM_MOUSEWHEEL = 522U;
        internal const uint WM_POINTERWHEEL = 590U;
        internal const uint WM_POINTERENTER = 585U;
        internal const uint PEN_FLAG_NONE = 0U;
        internal const uint PEN_FLAG_BARREL = 1U;
        internal const uint PEN_FLAG_INVERTED = 2U;
        internal const uint PEN_FLAG_ERASER = 4U;
        internal const uint PEN_MASK_PRESSURE = 1U;
        internal const uint PEN_MASK_ROTATION = 2U;
        internal const uint PEN_MASK_TILT_X = 4U;
        internal const uint PEN_MASK_TILT_Y = 8U;
        internal const uint TOUCH_FLAG_NONE = 0U;
        internal const uint TOUCH_MASK_CONTACTAREA = 1U;
        internal const uint TOUCH_MASK_ORIENTATION = 2U;
        internal const uint WM_MOUSEHWHEEL = 526U;
        internal const uint WM_XBUTTONDBLCLK = 525U;
        internal const uint WM_KEYDOWN = 256U;
    }
    /// <content>
	/// Contains extern methods from "GDI32.dll".
	/// </content>
	internal static partial class PInvoke
    {
        /// <summary>The DeleteObject function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid.</summary>
        /// <param name="ho">A handle to a logical pen, brush, font, bitmap, region, or palette.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. If the specified handle is not valid or is currently selected into a DC, the return value is zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//wingdi/nf-wingdi-deleteobject">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("GDI32.dll", ExactSpelling = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern winmdroot.Foundation.BOOL DeleteObject(winmdroot.Graphics.Gdi.HGDIOBJ ho);
    }
    /// <content>
	/// Contains extern methods from "KERNEL32.dll".
	/// </content>
	[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.104-beta+6d86f35b75")]
    internal static partial class PInvoke
    {
        /// <summary>Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.</summary>
        /// <param name="hLibModule">
        /// <para>A handle to the loaded library module. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandleexa">GetModuleHandleEx</a> function returns this handle.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freelibrary#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call the <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> function.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-freelibrary">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern winmdroot.Foundation.BOOL FreeLibrary(winmdroot.Foundation.HINSTANCE hLibModule);

        /// <inheritdoc cref="GetProcAddress(winmdroot.Foundation.HINSTANCE, winmdroot.Foundation.PCSTR)"/>
        internal static unsafe winmdroot.Foundation.FARPROC GetProcAddress(SafeHandle hModule, string lpProcName)
        {
            bool hModuleAddRef = false;
            try
            {
                fixed (byte* lpProcNameLocal = lpProcName is object ? global::System.Text.Encoding.UTF8.GetBytes(lpProcName) : null)
                {
                    winmdroot.Foundation.HINSTANCE hModuleLocal;
                    if (hModule is object)
                    {
                        hModule.DangerousAddRef(ref hModuleAddRef);
                        hModuleLocal = (winmdroot.Foundation.HINSTANCE)hModule.DangerousGetHandle();
                    }
                    else
                        hModuleLocal = default(winmdroot.Foundation.HINSTANCE);
                    winmdroot.Foundation.FARPROC __result = PInvoke.GetProcAddress(hModuleLocal, new winmdroot.Foundation.PCSTR(lpProcNameLocal));
                    return __result;
                }
            }
            finally
            {
                if (hModuleAddRef)
                    hModule.DangerousRelease();
            }
        }

        /// <summary>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</summary>
        /// <param name="hModule">
        /// <para>A handle to the DLL module that contains the function or variable. The <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibrary</a>, <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>, <a href="https://docs.microsoft.com/windows/desktop/api/winbase/nf-winbase-loadpackagedlibrary">LoadPackagedLibrary</a>, or <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> function returns this handle. The <b>GetProcAddress</b> function does not retrieve addresses from modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getprocaddress#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <param name="lpProcName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
        /// <returns>
        /// <para>If the function succeeds, the return value is the address of the exported function or variable. If the function fails, the return value is NULL. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getprocaddress">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern winmdroot.Foundation.FARPROC GetProcAddress(winmdroot.Foundation.HINSTANCE hModule, winmdroot.Foundation.PCSTR lpProcName);

        /// <inheritdoc cref="GetModuleHandle(winmdroot.Foundation.PCWSTR)"/>
        internal static unsafe FreeLibrarySafeHandle GetModuleHandle(string lpModuleName)
        {
            fixed (char* lpModuleNameLocal = lpModuleName)
            {
                winmdroot.Foundation.HINSTANCE __result = PInvoke.GetModuleHandle(lpModuleNameLocal);
                return new FreeLibrarySafeHandle(__result, ownsHandle: false);
            }
        }

        /// <summary>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</summary>
        /// <param name="lpModuleName">
        /// <para>The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.</para>
        /// <para>If this parameter is NULL, <b>GetModuleHandle</b> returns a handle to the file used to create the calling process (.exe file). The <b>GetModuleHandle</b> function does not retrieve handles for modules that were loaded using the <b>LOAD_LIBRARY_AS_DATAFILE</b> flag. For more information, see <a href="https://docs.microsoft.com/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibraryexa">LoadLibraryEx</a>.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulehandlew#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>If the function succeeds, the return value is a handle to the specified module. If the function fails, the return value is NULL. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//libloaderapi/nf-libloaderapi-getmodulehandlew">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("KERNEL32.dll", ExactSpelling = true, EntryPoint = "GetModuleHandleW", SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern winmdroot.Foundation.HINSTANCE GetModuleHandle(winmdroot.Foundation.PCWSTR lpModuleName);

        /// <summary>Retrieves the frequency of the performance counter.</summary>
        /// <param name="lpFrequency">A pointer to a variable that receives the current performance-counter frequency, in counts per second. If the installed hardware doesn't support a high-resolution performance counter, this parameter can be zero (this will not occur on systems that run Windows XP or later).</param>
        /// <returns>
        /// <para>If the installed hardware supports a high-resolution performance counter, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>. On systems that run Windows XP or later, the function will always succeed and will thus never return zero.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//profileapi/nf-profileapi-queryperformancefrequency">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("KERNEL32.dll", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern unsafe winmdroot.Foundation.BOOL QueryPerformanceFrequency(long* lpFrequency);
    }
    /// <content>
	/// Contains extern methods from "USER32.dll".
	/// </content>
	internal static partial class PInvoke
    {
        /// <summary>Destroys an icon and frees any memory the icon occupied.</summary>
        /// <param name="hIcon">
        /// <para>Type: <b>HICON</b> A handle to the icon to be destroyed. The icon must not be in use.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroyicon#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroyicon">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern winmdroot.Foundation.BOOL DestroyIcon(winmdroot.UI.WindowsAndMessaging.HICON hIcon);

        /// <summary>Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.</summary>
        /// <param name="hCursor">
        /// <para>Type: <b>HCURSOR</b> A handle to the cursor to be destroyed. The cursor must not be in use.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroycursor#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroycursor">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern winmdroot.Foundation.BOOL DestroyCursor(winmdroot.UI.WindowsAndMessaging.HCURSOR hCursor);

        /// <summary>Destroys the specified window.</summary>
        /// <param name="hWnd">
        /// <para>Type: <b>HWND</b> A handle to the window to be destroyed.</para>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroywindow#parameters">Read more on docs.microsoft.com</see>.</para>
        /// </param>
        /// <returns>
        /// <para>Type: <b>BOOL</b> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call <a href="/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>.</para>
        /// </returns>
        /// <remarks>
        /// <para><see href="https://docs.microsoft.com/windows/win32/api//winuser/nf-winuser-destroywindow">Learn more about this API from docs.microsoft.com</see>.</para>
        /// </remarks>
        [DllImport("USER32.dll", ExactSpelling = true, SetLastError = true)]
        [DefaultDllImportSearchPaths(DllImportSearchPath.System32)]
        internal static extern winmdroot.Foundation.BOOL DestroyWindow(winmdroot.Foundation.HWND hWnd);
    }
}
