// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#pragma warning disable CS1591,CS1573,CS0465,CS0649,CS8019,CS1570,CS1584,CS1658,CS0436,CS8981
using global::System;
using global::System.Diagnostics;
using global::System.Diagnostics.CodeAnalysis;
using global::System.Runtime.CompilerServices;
using global::System.Runtime.InteropServices;
using winmdroot = global::Windows.Win32;
namespace Windows.Win32
{
    namespace Foundation
    {
        [DebuggerDisplay("{Value}")]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.104-beta+6d86f35b75")]
        internal readonly partial struct BOOL
            : IEquatable<BOOL>
        {
            internal readonly int Value;
            internal BOOL(int value) => this.Value = value;
            public static implicit operator int(BOOL value) => value.Value;
            public static explicit operator BOOL(int value) => new BOOL(value);
            public static bool operator ==(BOOL left, BOOL right) => left.Value == right.Value;
            public static bool operator !=(BOOL left, BOOL right) => !(left == right);

            public bool Equals(BOOL other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is BOOL other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();
            internal BOOL(bool value) => this.Value = value ? 1 : 0;
            public static implicit operator bool(BOOL value) => value.Value != 0;
            public static implicit operator BOOL(bool value) => new BOOL(value);
        }
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.104-beta+6d86f35b75")]
        internal partial struct FARPROC
        {
            internal IntPtr Value;
            internal FARPROC(IntPtr value) => this.Value = value;

            internal static FARPROC Null => default;

            internal bool IsNull => Value == default;
            public static implicit operator IntPtr(FARPROC value) => value.Value;
            public static explicit operator FARPROC(IntPtr value) => new FARPROC(value);
            public static bool operator ==(FARPROC left, FARPROC right) => left.Value == right.Value;
            public static bool operator !=(FARPROC left, FARPROC right) => !(left == right);

            public bool Equals(FARPROC other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is FARPROC other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();

            internal TDelegate CreateDelegate<TDelegate>() where TDelegate : Delegate => Marshal.GetDelegateForFunctionPointer<TDelegate>(this.Value);
        }
        [DebuggerDisplay("{Value}")]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.104-beta+6d86f35b75")]
        internal readonly partial struct HINSTANCE
            : IEquatable<HINSTANCE>
        {
            internal readonly IntPtr Value;
            internal HINSTANCE(IntPtr value) => this.Value = value;

            internal static HINSTANCE Null => default;

            internal bool IsNull => Value == default;
            public static implicit operator IntPtr(HINSTANCE value) => value.Value;
            public static explicit operator HINSTANCE(IntPtr value) => new HINSTANCE(value);
            public static bool operator ==(HINSTANCE left, HINSTANCE right) => left.Value == right.Value;
            public static bool operator !=(HINSTANCE left, HINSTANCE right) => !(left == right);

            public bool Equals(HINSTANCE other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is HINSTANCE other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();
        }
        [DebuggerDisplay("{Value}")]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.104-beta+6d86f35b75")]
        internal readonly partial struct HRESULT
            : IEquatable<HRESULT>
        {
            internal readonly int Value;
            internal HRESULT(int value) => this.Value = value;
            public static implicit operator int(HRESULT value) => value.Value;
            public static explicit operator HRESULT(int value) => new HRESULT(value);
            public static bool operator ==(HRESULT left, HRESULT right) => left.Value == right.Value;
            public static bool operator !=(HRESULT left, HRESULT right) => !(left == right);

            public bool Equals(HRESULT other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is HRESULT other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();
            public static implicit operator uint(HRESULT value) => (uint)value.Value;
            public static explicit operator HRESULT(uint value) => new HRESULT((int)value);


            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            internal bool Succeeded => this.Value >= 0;


            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            internal bool Failed => this.Value < 0;


            /// <inheritdoc cref="Marshal.ThrowExceptionForHR(int, IntPtr)" />
            /// <param name="errorInfo">
            /// A pointer to the IErrorInfo interface that provides more information about the
            /// error. You can specify <see cref="IntPtr.Zero"/> to use the current IErrorInfo interface, or
            /// <c>new IntPtr(-1)</c> to ignore the current IErrorInfo interface and construct the exception
            /// just from the error code.
            /// </param>
            /// <returns><see langword="this"/> <see cref="HRESULT"/>, if it does not reflect an error.</returns>
            /// <seealso cref="Marshal.ThrowExceptionForHR(int, IntPtr)"/>
            internal HRESULT ThrowOnFailure(IntPtr errorInfo = default)

            {
                Marshal.ThrowExceptionForHR(this.Value, errorInfo);
                return this;
            }


            public override string ToString() => string.Format(global::System.Globalization.CultureInfo.InvariantCulture, "0x{0:X8}", this.Value);


            internal string ToString(string format, IFormatProvider formatProvider) => ((uint)this.Value).ToString(format, formatProvider);
            /// <summary>Documentation varies per use. Refer to each: <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnsmsevents-onsmssendcomplete">IMbnSmsEvents.OnSmsSendComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnconnectioncontextevents-onsetprovisionedcontextcomplete">IMbnConnectionContextEvents.OnSetProvisionedContextComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnserviceactivationevents-onactivationcomplete">IMbnServiceActivationEvents.OnActivationComplete</see>.</summary>
            internal static readonly winmdroot.Foundation.HRESULT E_INVALIDARG = (winmdroot.Foundation.HRESULT)(-2147024809);
            /// <summary>Documentation varies per use. Refer to each: <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnradioevents-onsetsoftwareradiostatecomplete">IMbnRadioEvents.OnSetSoftwareRadioStateComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnsmsevents-onsmssendcomplete">IMbnSmsEvents.OnSmsSendComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnpinmanagerevents-ongetpinstatecomplete">IMbnPinManagerEvents.OnGetPinStateComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnpinevents-onchangecomplete">IMbnPinEvents.OnChangeComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnsmsevents-onsetsmsconfigurationcomplete">IMbnSmsEvents.OnSetSmsConfigurationComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnpinevents-onentercomplete">IMbnPinEvents.OnEnterComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnpinevents-onunblockcomplete">IMbnPinEvents.OnUnblockComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnsmsevents-onsmsdeletecomplete">IMbnSmsEvents.OnSmsDeleteComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnsmsevents-onsmsreadcomplete">IMbnSmsEvents.OnSmsReadComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnconnectioncontextevents-onsetprovisionedcontextcomplete">IMbnConnectionContextEvents.OnSetProvisionedContextComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnpinevents-onenablecomplete">IMbnPinEvents.OnEnableComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnconnectionevents-onconnectcomplete">IMbnConnectionEvents.OnConnectComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnpinevents-ondisablecomplete">IMbnPinEvents.OnDisableComplete</see>, <see href="https://docs.microsoft.com/windows/win32/api//mbnapi/nf-mbnapi-imbnserviceactivationevents-onactivationcomplete">IMbnServiceActivationEvents.OnActivationComplete</see>.</summary>
            internal static readonly winmdroot.Foundation.HRESULT S_OK = (winmdroot.Foundation.HRESULT)(0);
        }
        [DebuggerDisplay("{Value}")]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.104-beta+6d86f35b75")]
        public readonly partial struct HWND
            : IEquatable<HWND>
        {
            public readonly IntPtr Value;
            public HWND(IntPtr value) => this.Value = value;

            public static HWND Null => default;

            internal bool IsNull => Value == default;
            public static implicit operator IntPtr(HWND value) => value.Value;
            public static explicit operator HWND(IntPtr value) => new HWND(value);
            public static bool operator ==(HWND left, HWND right) => left.Value == right.Value;
            public static bool operator !=(HWND left, HWND right) => !(left == right);

            public bool Equals(HWND other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is HWND other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();
        }
        [DebuggerDisplay("{Value}")]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.104-beta+6d86f35b75")]
        internal readonly partial struct LPARAM
            : IEquatable<LPARAM>
        {
            internal readonly nint Value;
            internal LPARAM(nint value) => this.Value = value;
            public static implicit operator nint(LPARAM value) => value.Value;
            public static implicit operator LPARAM(nint value) => new LPARAM(value);
            public static bool operator ==(LPARAM left, LPARAM right) => left.Value == right.Value;
            public static bool operator !=(LPARAM left, LPARAM right) => !(left == right);

            public bool Equals(LPARAM other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is LPARAM other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();
        }
        [DebuggerDisplay("{Value}")]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.104-beta+6d86f35b75")]
        internal readonly partial struct LRESULT
            : IEquatable<LRESULT>
        {
            internal readonly nint Value;
            internal LRESULT(nint value) => this.Value = value;
            public static implicit operator nint(LRESULT value) => value.Value;
            public static explicit operator LRESULT(nint value) => new LRESULT(value);
            public static bool operator ==(LRESULT left, LRESULT right) => left.Value == right.Value;
            public static bool operator !=(LRESULT left, LRESULT right) => !(left == right);

            public bool Equals(LRESULT other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is LRESULT other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();
        }
        /// <summary>
		/// A pointer to a constant character string.
		/// </summary>
		[DebuggerDisplay("{" + nameof(DebuggerDisplay) + "}")]
        internal unsafe readonly partial struct PCSTR
            : IEquatable<PCSTR>
        {
            /// <summary>
            /// A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            /// </summary>
            internal readonly byte* Value;
            internal PCSTR(byte* value) => this.Value = value;
            public static implicit operator byte*(PCSTR value) => value.Value;
            public static explicit operator PCSTR(byte* value) => new PCSTR(value);

            public bool Equals(PCSTR other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is PCSTR other && this.Equals(other);

            public override int GetHashCode() => unchecked((int)this.Value);


            /// <summary>
            /// Gets the number of characters up to the first null character (exclusive).
            /// </summary>
            internal int Length
            {
                get
                {
                    byte* p = this.Value;
                    if (p is null)
                        return 0;
                    while (*p != 0)
                        p++;
                    return checked((int)(p - this.Value));
                }
            }


            /// <summary>
            /// Returns a <see langword="string"/> with a copy of this character array, decoding as UTF-8.
            /// </summary>
            /// <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="Value"/> is <see langword="null"/>.</returns>
            public override string ToString() => this.Value is null ? null : new string((sbyte*)this.Value, 0, this.Length, global::System.Text.Encoding.UTF8);



            private string DebuggerDisplay => this.ToString();
        }
        /// <summary>
		/// A pointer to a constant character string.
		/// </summary>
		[DebuggerDisplay("{" + nameof(DebuggerDisplay) + "}")]
        internal unsafe readonly partial struct PCWSTR
            : IEquatable<PCWSTR>
        {
            /// <summary>
            /// A pointer to the first character in the string. The content should be considered readonly, as it was typed as constant in the SDK.
            /// </summary>
            internal readonly char* Value;
            internal PCWSTR(char* value) => this.Value = value;
            public static explicit operator char*(PCWSTR value) => value.Value;
            public static implicit operator PCWSTR(char* value) => new PCWSTR(value);

            public bool Equals(PCWSTR other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is PCWSTR other && this.Equals(other);

            public override int GetHashCode() => unchecked((int)this.Value);


            /// <summary>
            /// Gets the number of characters up to the first null character (exclusive).
            /// </summary>
            internal int Length
            {
                get
                {
                    char* p = this.Value;
                    if (p is null)
                        return 0;
                    while (*p != '\0')
                        p++;
                    return checked((int)(p - this.Value));
                }
            }


            /// <summary>
            /// Returns a <see langword="string"/> with a copy of this character array.
            /// </summary>
            /// <returns>A <see langword="string"/>, or <see langword="null"/> if <see cref="Value"/> is <see langword="null"/>.</returns>
            public override string ToString() => this.Value is null ? null : new string(this.Value);



            private string DebuggerDisplay => this.ToString();
        }
        /// <summary>The RECT structure defines a rectangle by the coordinates of its upper-left and lower-right corners.</summary>
		/// <remarks>
		/// <para>The RECT structure is identical to the <a href="https://docs.microsoft.com/windows/desktop/api/windef/ns-windef-rectl">RECTL</a> structure.</para>
		/// <para><see href="https://docs.microsoft.com/windows/win32/api//windef/ns-windef-rect#">Read more on docs.microsoft.com</see>.</para>
		/// </remarks>
		[global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.104-beta+6d86f35b75")]
        internal partial struct RECT
        {
            /// <summary>Specifies the <i>x</i>-coordinate of the upper-left corner of the rectangle.</summary>
            internal int left;
            /// <summary>Specifies the <i>y</i>-coordinate of the upper-left corner of the rectangle.</summary>
            internal int top;
            /// <summary>Specifies the <i>x</i>-coordinate of the lower-right corner of the rectangle.</summary>
            internal int right;
            /// <summary>Specifies the <i>y</i>-coordinate of the lower-right corner of the rectangle.</summary>
            internal int bottom;
            internal RECT(global::System.Drawing.Rectangle value) :
this(value.Left, value.Top, value.Right, value.Bottom)
            {
            }
            internal RECT(global::System.Drawing.Point location, global::System.Drawing.Size size) :
this(location.X, location.Y, unchecked(location.X + size.Width), unchecked(location.Y + size.Height))
            {
            }
            internal RECT(int left, int top, int right, int bottom)

            {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }


            internal static RECT FromXYWH(int x, int y, int width, int height) =>
new RECT(x, y, unchecked(x + width), unchecked(y + height));

            internal readonly int Width => unchecked(this.right - this.left);

            internal readonly int Height => unchecked(this.bottom - this.top);

            internal readonly bool IsEmpty => this.left == 0 && this.top == 0 && this.right == 0 && this.bottom == 0;

            internal readonly int X => this.left;

            internal readonly int Y => this.top;

            internal readonly global::System.Drawing.Size Size => new global::System.Drawing.Size(this.Width, this.Height);
            public static implicit operator global::System.Drawing.Rectangle(RECT value) => new global::System.Drawing.Rectangle(value.left, value.top, value.Width, value.Height);
            public static implicit operator global::System.Drawing.RectangleF(RECT value) => new global::System.Drawing.RectangleF(value.left, value.top, value.Width, value.Height);
            public static implicit operator RECT(global::System.Drawing.Rectangle value) => new RECT(value);
        }
        [DebuggerDisplay("{Value}")]
        [global::System.CodeDom.Compiler.GeneratedCode("Microsoft.Windows.CsWin32", "0.2.104-beta+6d86f35b75")]
        internal readonly partial struct WPARAM
            : IEquatable<WPARAM>
        {
            internal readonly nuint Value;
            internal WPARAM(nuint value) => this.Value = value;
            public static implicit operator nuint(WPARAM value) => value.Value;
            public static implicit operator WPARAM(nuint value) => new WPARAM(value);
            public static bool operator ==(WPARAM left, WPARAM right) => left.Value == right.Value;
            public static bool operator !=(WPARAM left, WPARAM right) => !(left == right);

            public bool Equals(WPARAM other) => this.Value == other.Value;

            public override bool Equals(object obj) => obj is WPARAM other && this.Equals(other);

            public override int GetHashCode() => this.Value.GetHashCode();
        }
    }
}
